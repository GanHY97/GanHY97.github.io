<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>杂</title>
      <link href="2022/03/07/%E6%9D%82/"/>
      <url>2022/03/07/%E6%9D%82/</url>
      
        <content type="html"><![CDATA[<h1>解决粘包分包问题</h1><p>在项目开发中，采用自定义的报文格式，报文长度+报文内容 例：0010abcdefghi</p><h1>网络字节序和主机字节序</h1><p>网络字节顺序NBO(Network Byte Order): 按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。</p><p>主机字节顺序(HBO，Host Byte Order): 不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的,而与操作系统无关。如 Intel x86结构下, short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12 。如 IBM power PC结构下, short型数0x1234表示为12 34, int型数0x12345678表示为12 34 56 78。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="2021/11/04/http/"/>
      <url>2021/11/04/http/</url>
      
        <content type="html"><![CDATA[<h1>http基本概念</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Classification-by-Fusing-Multimodal-Data</title>
      <link href="2021/10/09/Classification-by-Fusing-Multimodal-Data/"/>
      <url>2021/10/09/Classification-by-Fusing-Multimodal-Data/</url>
      
        <content type="html"><![CDATA[<p><img src="%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE.png" alt="alt"></p><hr><h2 id="全文："><a class="header-anchor" href="#全文：">¶</a>全文：</h2><p><a href="https://www.mdpi.com/2220-9964/10/10/636">论文链接</a></p><h2 id="代码："><a class="header-anchor" href="#代码：">¶</a>代码：</h2><p><a href="https://github.com/GanHY97/Classification-by-Fusing-Multimodal-Data">github</a></p><h2 id="代码结构目录："><a class="header-anchor" href="#代码结构目录：">¶</a>代码结构目录：</h2><p><img src="%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95.png" alt="alt"><br><img src="data%E7%9B%AE%E5%BD%95.png" alt="alt"><br><img src="mul%E7%9B%AE%E5%BD%95.png" alt="alt"><br><img src="nlp%E7%9B%AE%E5%BD%95.png" alt="alt"></p><p>​代码一般都是半夜写的，只想着能不能跑通没在意结构，现在实验都做完了论文也发了懒得再动代码了（主要怕自己优化结构后出BUG）就大概讲一下代码流程吧。</p><p>​不要问为啥根目录是zywang <span class="github-emoji" style="display:inline;vertical-align:middle"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在人家服务器上跑的。</p><h2 id="代码流程："><a class="header-anchor" href="#代码流程：">¶</a>代码流程：</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>数据集划分：按照 70:15:15 划分数据集包括文本和图片（主要使用xlrd包对数据集annotations中的文件进行处理，也可以使用其他方法对.tsv文件进行处理）</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>使用train_vgg训练VGG16模型，得到xx.pth</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>使用nlp中的main.py训练FastTest模型，生成xx.bin</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>分别调用.pth和.bin文件生成vector</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>将生成的vector放入train_softmax.py进行训练</p>]]></content>
      
      
      <categories>
          
          <category> 小论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastText </tag>
            
            <tag> vgg </tag>
            
            <tag> multimodal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="2021/08/01/socket/"/>
      <url>2021/08/01/socket/</url>
      
        <content type="html"><![CDATA[<h1>Socket基本操作</h1><p><a href="https://blog.csdn.net/pashanhu6402/article/details/96428887">原文链接</a></p><p>socket是“open—write/read—close”模式的一种实现，下面以TCP为例。</p><p><img src="1.png" alt="TCP"></p><h2 id="socket-函数"><a class="header-anchor" href="#socket-函数">¶</a>socket()函数</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，<strong>AF_INET</strong>、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，<strong>SOCK_STREAM</strong>、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有，<strong>IPPROTO_TCP</strong>、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、SCTP传输协议、TIPC传输协议。</li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h2 id="bind-函数"><a class="header-anchor" href="#bind-函数">¶</a>bind()函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> {</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; </span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> {</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>ipv6对应的是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> {</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;    </span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;      </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>      </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id;  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> {</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>Unix域对应的是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> {</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;                </span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><h2 id="listen-、connect-函数"><a class="header-anchor" href="#listen-、connect-函数">¶</a>listen()、connect()函数</h2><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h2 id="accept-函数"><a class="header-anchor" href="#accept-函数">¶</a>accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p><h2 id="read-、write-等函数"><a class="header-anchor" href="#read-、write-等函数">¶</a>read()、write()等函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节 数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是 全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p><h2 id="close-函数"><a class="header-anchor" href="#close-函数">¶</a>close()函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h1>socket中TCP的三次握手建立连接详解</h1><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="2.png" alt="TCP三次握手"></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><h1>socket中TCP的四次握手释放连接详解</h1><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="3.png" alt="TCP四次握手"></p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> TCP </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调度程序</title>
      <link href="2021/06/16/%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F/"/>
      <url>2021/06/16/%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>僵尸进程</h1><h2 id="什么是僵尸进程"><a class="header-anchor" href="#什么是僵尸进程">¶</a>什么是僵尸进程</h2><p>僵尸进程是指它的父进程已经退出(父进程没有等待(调用wait/waitpid)它)，而该进程dead之后没有进程接受，就成为僵尸进程，也就是(zombie)进程。</p><h2 id="产生原因"><a class="header-anchor" href="#产生原因">¶</a>产生原因</h2><p>一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程(Zombie)的数据结构 (系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁)。</p><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保 留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸。</p><p>如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。</p><p>但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。系统所能使用的进程号是有限的,如果大量的产生僵死进程,将因为没有可用的进程号而导致系统不能产生新的进程。（ps -ef|grep defunc查看僵尸进程）</p><h2 id="如何避免"><a class="header-anchor" href="#如何避免">¶</a>如何避免</h2><ul><li>父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起；</li><li>如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后，父进程会收到该信号，可以在handler中调用wait回收；</li><li>如果父进程不关心子进程什么时候结束，那么可以用signal(SIGCHLD, SIG_IGN) 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号；</li></ul><h2 id="如何处理"><a class="header-anchor" href="#如何处理">¶</a>如何处理</h2><ul><li><p>改写父进程</p></li><li><p>kill -18 PPID　(PPID是其父进程)</p><p>这个信号是告诉父进程，该子进程已经死亡了，请收回分配给他的资源。</p></li><li><p>终止父进程</p><p>kill -15 PPID</p></li></ul><h1>调度程序</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (argc&lt;<span class="number">3</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using:./procctl timetvl program argv ...\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Example:/project/tools1/bin/procctl 5 /usr/bin/tar zcvf /tmp/tmp.tgz /usr/include\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"本程序是服务程序的调度程序，周期性启动服务程序或shell脚本。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"timetvl 运行周期，单位：秒。被调度的程序运行结束后，在timetvl秒后会被procctl重新启动。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"program 被调度的程序名，必须使用全路径。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argvs   被调度的程序的参数。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"注意，本程序不会被kill杀死，但可以用kill -9强行杀死。\n\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭信号和IO，本程序不希望被打扰。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">64</span>;ii++)</span><br><span class="line">  {</span><br><span class="line">    signal(ii,SIG_IGN); close(ii);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管。</span></span><br><span class="line">  <span class="keyword">if</span> (fork()!=<span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启用SIGCHLD信号，让父进程可以wait子进程退出的状态。</span></span><br><span class="line">  signal(SIGCHLD,SIG_DFL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *pargv[argc];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">2</span>;ii&lt;argc;ii++)</span><br><span class="line">    pargv[ii<span class="number">-2</span>]=argv[ii];</span><br><span class="line"></span><br><span class="line">  pargv[argc<span class="number">-2</span>]=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> (fork()==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      execv(argv[<span class="number">2</span>],pargv);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      wait(&amp;status);</span><br><span class="line">      sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 僵尸进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>守护进程</title>
      <link href="2021/06/13/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/06/13/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行的日志。</span></span><br><span class="line">CLogFile logfile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 程序的帮助。</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using:./checkproc logfilename\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Example:/project/tools1/bin/procctl 10 /project/tools1/bin/checkproc /tmp/log/checkproc.log\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"本程序用于检查后台服务程序是否超时，如果已超时，就终止它。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"注意：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  1）本程序由procctl启动，运行周期建议为10秒。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  2）为了避免被普通用户误杀，本程序应该用root用户启动。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  3）如果要停止本程序，只能用killall -9 终止。\n\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略全部的信号和IO，不希望程序被干扰。</span></span><br><span class="line">  CloseIOAndSignal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开日志文件。</span></span><br><span class="line">  <span class="keyword">if</span> (logfile.Open(argv[<span class="number">1</span>],<span class="string">"a+"</span>)==<span class="literal">false</span>)</span><br><span class="line">  { <span class="built_in">printf</span>(<span class="string">"logfile.Open(%s) failed.\n"</span>,argv[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> shmid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。</span></span><br><span class="line">  <span class="keyword">if</span> ( (shmid = shmget((<span class="keyword">key_t</span>)SHMKEYP, MAXNUMP*<span class="keyword">sizeof</span>(struct st_procinfo), <span class="number">0666</span>|IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">  {</span><br><span class="line">    logfile.Write(<span class="string">"创建/获取共享内存(%x)失败。\n"</span>,SHMKEYP); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将共享内存连接到当前进程的地址空间。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_procinfo</span> *<span class="title">shm</span>=</span>(struct st_procinfo *)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历共享内存中全部的记录。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;MAXNUMP;ii++)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// 如果记录的pid==0，表示空记录，continue;</span></span><br><span class="line">    <span class="keyword">if</span> (shm[ii].pid==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果记录的pid!=0，表示是服务程序的心跳记录。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序稳定运行后，以下两行代码可以注释掉。</span></span><br><span class="line">    <span class="comment">//logfile.Write("ii=%d,pid=%d,pname=%s,timeout=%d,atime=%d\n",\</span></span><br><span class="line">    <span class="comment">//               ii,shm[ii].pid,shm[ii].pname,shm[ii].timeout,shm[ii].atime);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向进程发送信号0，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue;</span></span><br><span class="line">    <span class="keyword">int</span> iret=kill(shm[ii].pid,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (iret==<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      logfile.Write(<span class="string">"进程pid=%d(%s)已经不存在。\n"</span>,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class="line">      <span class="built_in">memset</span>(shm+ii,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct st_procinfo)); <span class="comment">// 从共享内存中删除该记录。</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> now=time(<span class="number">0</span>);   <span class="comment">// 取当前时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程未超时，continue;</span></span><br><span class="line">    <span class="keyword">if</span> (now-shm[ii].atime&lt;shm[ii].timeout) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已超时。</span></span><br><span class="line">    logfile.Write(<span class="string">"进程pid=%d(%s)已经超时。\n"</span>,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号15，尝试正常终止进程。</span></span><br><span class="line">    kill(shm[ii].pid,<span class="number">15</span>);     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔1秒判断一次进程是否存在，累计5秒，一般来说，5秒的时间足够让进程退出。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;<span class="number">5</span>;jj++)</span><br><span class="line">    {</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      iret=kill(shm[ii].pid,<span class="number">0</span>);     <span class="comment">// 向进程发送信号0，判断它是否还存在。</span></span><br><span class="line">      <span class="keyword">if</span> (iret==<span class="number">-1</span>) <span class="keyword">break</span>;     <span class="comment">// 进程已退出。</span></span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程仍存在，就发送信号9，强制终止它。</span></span><br><span class="line">    <span class="keyword">if</span> (iret==<span class="number">-1</span>)</span><br><span class="line">      logfile.Write(<span class="string">"进程pid=%d(%s)已经正常终止。\n"</span>,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      kill(shm[ii].pid,<span class="number">9</span>);  <span class="comment">// 如果进程仍存在，就发送信号9，强制终止它。</span></span><br><span class="line">      logfile.Write(<span class="string">"进程pid=%d(%s)已经强制终止。\n"</span>,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从共享内存中删除已超时进程的心跳记录。</span></span><br><span class="line">    <span class="built_in">memset</span>(shm+ii,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct st_procinfo)); <span class="comment">// 从共享内存中删除该记录。</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把共享内存从当前进程中分离。</span></span><br><span class="line">  shmdt(shm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 心跳机制，守护进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux信号量</title>
      <link href="2021/06/13/linux%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>2021/06/13/linux%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1>信号量的概念</h1><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读/写。它不以传送数据为目的，主要是用来保护共享资源（共享内存、消息队列、socket连接池、数据库连接池等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值0和1的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少。</p><p>本文只介绍二元信号量。</p><h1>相关函数</h1><p>Linux中提供了一组函数用于操作信号量，程序中需要包含以下头文件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="semget函数"><a class="header-anchor" href="#semget函数">¶</a>semget函数</h2><p>semget函数用来获取或创建信号量，它的原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>1）参数key是信号量的键值，typedef unsigned int key_t，是信号量在系统中的编号，不同信号量的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>2）参数nsems是创建信号量集中信号量的个数，该参数只在创建信号量集时有效，这里固定填1。</p><p>3）参数sem_flags是一组标志，如果希望信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。如果没有设置IPC_CREAT标志并且信号量不存在，就会返错误（errno的值为2，No such file or directory）。</p><p>4）如果semget函数成功，返回信号量集的标识；失败返回-1，错误原因存于error中。</p><p>示例：</p><p>1）获取键值为0x5000的信号量，如果该信号量不存在，就创建它，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> semid=semget(<span class="number">0x5000</span>,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT); </span><br></pre></td></tr></tbody></table></figure><p>2）获取键值为0x5000的信号量，如果该信号量不存在，返回-1，errno的值被设置为2，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> semid= semget(<span class="number">0x5000</span>,<span class="number">1</span>,<span class="number">0640</span>)；</span><br></pre></td></tr></tbody></table></figure><h2 id="semctl函数"><a class="header-anchor" href="#semctl函数">¶</a>semctl函数</h2><p>该函数用来控制信号量（常用于设置信号量的初始值和销毁信号量），它的原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>1）参数semid是由semget函数返回的信号量标识。</p><p>2）参数sem_num是信号量集数组上的下标，表示某一个信号量，填0。</p><p>3）参数cmd是对信号量操作的命令种类，常用的有以下两个：</p><p><strong>IPC_RMID</strong>：销毁信号量，不需要第四个参数；</p><p><strong>SETVAL</strong>：初始化信号量的值（信号量成功创建后，需要设置初始值），这个值由第四个参数决定。第四参数是一个自定义的共同体，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>4）如果semctl函数调用失败返回-1；如果成功，返回值比较复杂，暂时不关心它。</p><p>示例：</p><p>1）销毁信号量。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semctl(semid,<span class="number">0</span>,IPC_RMID);</span><br></pre></td></tr></tbody></table></figure><p>2）初始化信号量的值为1，信号量可用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">sem_union.val = <span class="number">1</span>;</span><br><span class="line">semctl(semid,<span class="number">0</span>,SETVAL,sem_union);</span><br></pre></td></tr></tbody></table></figure><h2 id="semop函数"><a class="header-anchor" href="#semop函数">¶</a>semop函数</h2><p>该函数有两个功能：1）等待信号量的值变为1，如果等待成功，立即把信号量的值置为0，这个过程也称之为等待锁；2）把信号量的值置为1，这个过程也称之为释放锁。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>1）参数semid是由semget函数返回的信号量标识。</p><p>2）参数nsops是操作信号量的个数，即sops结构变量的个数，设置它的为1（只对一个信号量的操作）。</p><p>3）参数sops是一个结构体，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">short</span> sem_num;  <span class="comment">// 信号量集的个数，单个信号量设置为0。</span></span><br><span class="line"> <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量在本次操作中需要改变的数据：-1-等待操作；1-发送操作。</span></span><br><span class="line"> <span class="keyword">short</span> sem_flg;  <span class="comment">// 把此标志设置为SEM_UNDO，操作系统将跟踪这个信号量。</span></span><br><span class="line">          <span class="comment">// 如果当前进程退出时没有释放信号量，操作系统将释放信号量，避免资源被死锁。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p>1）等待信号量的值变为1，如果等待成功，立即把信号量的值置为0；</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">semop(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>2）把信号量的值置为1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">semop(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><h1>示例程序</h1><p>为了便于理解，我把信号量的操作封装成CSEM类，称之为信号灯，类似互斥锁，包括初始化信号灯、等待信号灯、挂出信号灯和销毁信号灯。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSEM</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">semun</span> // 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="class"> {</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;</span><br><span class="line"> };</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> sem_id; <span class="comment">// 信号灯描述符。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">key_t</span> key)</span></span>; <span class="comment">// 如果信号灯已存在，获取信号灯；如果信号灯不存在，则创建信号灯并初始化。</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>;     <span class="comment">// 等待信号灯挂出。</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>;     <span class="comment">// 挂出信号灯。</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">destroy</span><span class="params">()</span></span>;    <span class="comment">// 销毁信号灯。</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  CSEM sem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始信号灯。</span></span><br><span class="line">  <span class="keyword">if</span> (sem.init(<span class="number">0x5000</span>)==<span class="literal">false</span>) { <span class="built_in">printf</span>(<span class="string">"sem.init failed.\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sem.init ok\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">  <span class="keyword">if</span> (sem.wait()==<span class="literal">false</span>) { <span class="built_in">printf</span>(<span class="string">"sem.wait failed.\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sem.wait ok\n"</span>);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">50</span>); <span class="comment">// 在sleep的过程中，运行其它的book259程序将等待锁。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">  <span class="keyword">if</span> (sem.post()==<span class="literal">false</span>) { <span class="built_in">printf</span>(<span class="string">"sem.post failed.\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sem.post ok\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁信号灯。</span></span><br><span class="line">  <span class="comment">// if (sem.destroy()==false) { printf("sem.destroy failed.\n"); return -1; }</span></span><br><span class="line">  <span class="comment">// printf("sem.destroy ok\n");</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::init</span><span class="params">(<span class="keyword">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="comment">// 获取信号灯。</span></span><br><span class="line"> <span class="keyword">if</span> ( (sem_id=semget(key,<span class="number">1</span>,<span class="number">0640</span>)) == <span class="number">-1</span>) </span><br><span class="line"> { </span><br><span class="line">  <span class="comment">// 如果信号灯不存在，创建它。</span></span><br><span class="line">  <span class="keyword">if</span> (errno==<span class="number">2</span>) </span><br><span class="line">  {</span><br><span class="line">   <span class="keyword">if</span> ( (sem_id=semget(key,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>) { perror(<span class="string">"init 1 semget()"</span>); <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 信号灯创建成功后，还需要把它初始化成可用的状态。</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">   sem_union.val = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (semctl(sem_id,<span class="number">0</span>,SETVAL,sem_union) &lt; <span class="number">0</span>) { perror(<span class="string">"init semctl()"</span>); <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  { perror(<span class="string">"init 2 semget()"</span>); <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="keyword">if</span> (semctl(sem_id,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span>) { perror(<span class="string">"destroy semctl()"</span>); <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line"> sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line"> sem_b.sem_op = <span class="number">-1</span>; </span><br><span class="line"> sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> (semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) { perror(<span class="string">"wait semop()"</span>); <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSEM::post</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line"> sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line"> sem_b.sem_op = <span class="number">1</span>;  </span><br><span class="line"> sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> (semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) { perror(<span class="string">"post semop()"</span>); <span class="keyword">return</span> <span class="literal">false</span>; }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>其它的操作命令</h1><p>用ipcs -s可以查看系统的信号量，内容有键值（key），信号量编号（semid），创建者（owner），权限（perms），信号量数（nsems）。<br>用ipcrm sem 信号量编号，可以手工删除信号量</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内存共享</title>
      <link href="2021/06/11/Linux%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB/"/>
      <url>2021/06/11/Linux%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1>Linux内存共享</h1><h2 id="共享内存的概念"><a class="header-anchor" href="#共享内存的概念">¶</a>共享内存的概念</h2><p>共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读/写加锁，可以使用信号量。</p><h2 id="相关函数"><a class="header-anchor" href="#相关函数">¶</a>相关函数</h2><p>Linux中提供了一组函数用于操作共享内存，程序中需要包含以下头文件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="shmget函数"><a class="header-anchor" href="#shmget函数">¶</a>shmget函数</h3><p>shmget函数用来获取或创建共享内存，它的声明为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数key是共享内存的键值，是一个整数，typedef unsigned int key_t，是共享内存在系统中的编号，不同共享内存的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>参数size是待创建的共享内存的大小，以字节为单位。</p><p>参数shmflg是共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存。</p><h3 id="shmat函数"><a class="header-anchor" href="#shmat函数">¶</a>shmat函数</h3><p>把共享内存连接到当前进程的地址空间。它的声明如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数shm_id是由shmget函数返回的共享内存标识。</p><p>参数shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p>参数shm_flg是一组标志位，通常为0。</p><p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p><h3 id="shmdt函数"><a class="header-anchor" href="#shmdt函数">¶</a>shmdt函数</h3><p>该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。它的声明如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数shmaddr是shmat函数返回的地址。</p><p>调用成功时返回0，失败时返回-1.</p><h3 id="shmctl函数"><a class="header-anchor" href="#shmctl函数">¶</a>shmctl函数</h3><p>删除共享内存，它的声明如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数shm_id是shmget函数返回的共享内存标识符。</p><p>参数command填IPC_RMID。</p><p>参数buf填0。</p><p>解释一下，shmctl是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用，所以不介绍了。</p><p><strong>注意，用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。</strong></p><h2 id="示例程序"><a class="header-anchor" href="#示例程序">¶</a>示例程序</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">int</span> pid;    <span class="comment">// 进程编号。</span></span><br><span class="line"> <span class="keyword">char</span> name[<span class="number">51</span>]; <span class="comment">// 进程名称。</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="comment">// 共享内存的标志。</span></span><br><span class="line"> <span class="keyword">int</span> shmid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取或者创建共享内存，键值为0x5005。</span></span><br><span class="line"> <span class="keyword">if</span> ( (shmid=shmget(<span class="number">0x5005</span>, <span class="keyword">sizeof</span>(struct st_pid), <span class="number">0640</span>|IPC_CREAT))==<span class="number">-1</span>)</span><br><span class="line"> { <span class="built_in">printf</span>(<span class="string">"shmget(0x5005) failed\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 用于指向共享内存的结构体变量。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span> *<span class="title">stpid</span>=</span><span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 把共享内存连接到当前进程的地址空间。</span></span><br><span class="line"> <span class="keyword">if</span> ( (stpid=(struct st_pid *)shmat(shmid,<span class="number">0</span>,<span class="number">0</span>))==(<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line"> { <span class="built_in">printf</span>(<span class="string">"shmat failed\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pid=%d,name=%s\n"</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line"></span><br><span class="line"> stpid-&gt;pid=getpid();</span><br><span class="line"> <span class="built_in">strcpy</span>(stpid-&gt;name,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pid=%d,name=%s\n"</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把共享内存从当前进程中分离。</span></span><br><span class="line"> shmdt(stpid);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除共享内存。</span></span><br><span class="line"> <span class="comment">// if (shmctl(shmid,IPC_RMID,0)==-1)</span></span><br><span class="line"> <span class="comment">// { printf("shmctl failed\n"); return -1; }</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="其它的操作命令"><a class="header-anchor" href="#其它的操作命令">¶</a>其它的操作命令</h2><p>用ipcs -m可以查看系统的共享内存，内容有键值（key），共享内存编号（shmid），创建者（owner），权限（perms），大小（bytes）。</p><p>​</p><p>用ipcrm -m 共享内存编号，可以手工删除共享内存，如下：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号</title>
      <link href="2021/06/10/Linux%E4%BF%A1%E5%8F%B7/"/>
      <url>2021/06/10/Linux%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1>Linux信号</h1><h2 id="信号的基本概念"><a class="header-anchor" href="#信号的基本概念">¶</a>信号的基本概念</h2><p>信号（signal）是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据。</p><p>信号产生的原因有很多，在Linux下，可以用kill和killall命令发送信号。</p><h2 id="信号的类型"><a class="header-anchor" href="#信号的类型">¶</a>信号的类型</h2><table><thead><tr><th>信号名</th><th style="text-align:center">信号值</th><th style="text-align:center">默认处理动作</th><th style="text-align:left">发出信号的原因</th></tr></thead><tbody><tr><td>SIGHUP</td><td style="text-align:center">1</td><td style="text-align:center">A</td><td style="text-align:left">终端挂起或者控制进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>键盘中断Ctrl+c</strong></td></tr><tr><td>SIGQUIT</td><td style="text-align:center">3</td><td style="text-align:center">C</td><td style="text-align:left">键盘的退出键被按下</td></tr><tr><td>SIGILL</td><td style="text-align:center">4</td><td style="text-align:center">C</td><td style="text-align:left">非法指令</td></tr><tr><td>SIGABRT</td><td style="text-align:center">6</td><td style="text-align:center">C</td><td style="text-align:left">由abort(3)发出的退出指令</td></tr><tr><td>SIGFPE</td><td style="text-align:center">8</td><td style="text-align:center">C</td><td style="text-align:left">浮点异常</td></tr><tr><td><strong>SIGKILL</strong></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>AEF</strong></td><td style="text-align:left"><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td></tr><tr><td>SIGSEGV</td><td style="text-align:center">11</td><td style="text-align:center">C</td><td style="text-align:left">无效的内存引用</td></tr><tr><td>SIGPIPE</td><td style="text-align:center">13</td><td style="text-align:center">A</td><td style="text-align:left">管道破裂，写一个没有读端口的管道。</td></tr><tr><td><strong>SIGALRM</strong></td><td style="text-align:center"><strong>14</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>由alarm(2)发出的信号</strong></td></tr><tr><td><strong>SIGTERM</strong></td><td style="text-align:center"><strong>15</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td></tr><tr><td><strong>SIGUSR1</strong></td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>用户自定义信号1</strong></td></tr><tr><td><strong>SIGUSR2</strong></td><td style="text-align:center"><strong>12</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>用户自定义信号2</strong></td></tr><tr><td><strong>SIGCHLD</strong></td><td style="text-align:center"><strong>17</strong></td><td style="text-align:center"><strong>B</strong></td><td style="text-align:left"><strong>子进程结束信号</strong></td></tr><tr><td>SIGCONT</td><td style="text-align:center">18</td><td style="text-align:center"></td><td style="text-align:left">进程继续（曾被停止的进程）</td></tr><tr><td>SIGSTOP</td><td style="text-align:center">19</td><td style="text-align:center">DEF</td><td style="text-align:left">终止进程</td></tr><tr><td>SIGTSTP</td><td style="text-align:center">20</td><td style="text-align:center">D</td><td style="text-align:left">控制终端（tty）上按下停止键</td></tr><tr><td>SIGTTIN</td><td style="text-align:center">21</td><td style="text-align:center">D</td><td style="text-align:left">后台进程企图从控制终端读</td></tr><tr><td>SIGTTOU</td><td style="text-align:center">22</td><td style="text-align:center">D</td><td style="text-align:left">后台进程企图从控制终端写</td></tr></tbody></table><p>处理动作一项中的字母含义如下</p><p>A 缺省的动作是终止进程。</p><p>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。</p><p>C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</p><p>D 缺省的动作是停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。</p><p>E 信号不能被捕获。</p><p>F 信号不能被忽略。</p><h2 id="信号的处理"><a class="header-anchor" href="#信号的处理">¶</a>信号的处理</h2><p>进程对信号的处理方法有三种：</p><p>1）对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。</p><p>2）设置中断的处理函数，收到信号后，由该函数来处理。</p><p>3）忽略某个信号，对该信号不做任何处理，就像未发生过一样。</p><p>signal函数可以设置程序对信号的处理方式。</p><p>函数声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数signum表示信号的编号。</p><p>参数handler表示信号的处理方式，有三种情况：</p><p>1）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。</p><p>2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。</p><p>3）SIG_IGN：忽略参数signum所指的信号。</p><h2 id="信号有什么用"><a class="header-anchor" href="#信号有什么用">¶</a>信号有什么用</h2><p>服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有安排善后工作。</p><p>如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。</p><p>向服务程序发送0的信号，可以检测程序是否存活。</p><h2 id="信号应用示例"><a class="header-anchor" href="#信号应用示例">¶</a>信号应用示例</h2><p>在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">64</span>;ii++) signal(ii,SIG_IGN);</span><br></pre></td></tr></tbody></table></figure><p>这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。</p><p>程序在运行的进程中，如果按Ctrl+c，将向程序发出SIGINT信号，编号是2。</p><p>采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。</p><p>采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p><p>设置SIGINT和SIGTERM两个信号的处理函数，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* 本程序演示信号的用法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"收到了信号%d，程序退出。\n"</span>,sig);</span><br><span class="line"> <span class="comment">// 在这里添加释放资源的代码</span></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 程序退出。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">64</span>;ii++) signal(ii,SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"> signal(SIGINT,EXIT); signal(SIGTERM,EXIT); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// 每隔一秒执行一次任务。</span></span><br><span class="line"> {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"执行了一次任务。\n"</span>);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不管是用Ctrl+c还是kill，程序都能体面的退出。</p><h2 id="发送信号"><a class="header-anchor" href="#发送信号">¶</a>发送信号</h2><p>Linux操作系统提供了kill和killall命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。</p><p>函数声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>kill函数将参数sig指定的信号给参数pid 指定的进程。</p><p>参数pid 有几种情况：</p><p>1）pid&gt;0 将信号传给进程号为pid 的进程。</p><p>2）pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。</p><p>3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。</p><p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。</p><p>返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。</p><p>EINVAL：指定的信号码无效（参数 sig 不合法）。</p><p>EPERM：权限不够无法传送信号给指定进程。</p><p>ESRCH：参数 pid 所指定的进程或进程组不存在。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个博客</title>
      <link href="2021/01/07/hello-world/"/>
      <url>2021/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>本博客主要记录 <a href="https://github.com/GanHY97">XGG</a> 的一些学习日常以及生活点滴。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
