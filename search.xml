<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Classification-by-Fusing-Multimodal-Data</title>
      <link href="2021/10/09/Classification-by-Fusing-Multimodal-Data/"/>
      <url>2021/10/09/Classification-by-Fusing-Multimodal-Data/</url>
      
        <content type="html"><![CDATA[<p><img src="%E8%AE%BA%E6%96%87%E6%88%AA%E5%9B%BE.png" alt="alt"></p><hr><h2 id="全文："><a class="header-anchor" href="#全文：">¶</a>全文：</h2><p><a href="https://www.mdpi.com/2220-9964/10/10/636">论文链接</a></p><h2 id="代码："><a class="header-anchor" href="#代码：">¶</a>代码：</h2><p><a href="https://github.com/GanHY97/Classification-by-Fusing-Multimodal-Data">github</a></p><h2 id="代码结构目录："><a class="header-anchor" href="#代码结构目录：">¶</a>代码结构目录：</h2><p><img src="%E7%BB%93%E6%9E%84%E7%9B%AE%E5%BD%95.png" alt="alt"><br><img src="data%E7%9B%AE%E5%BD%95.png" alt="alt"><br><img src="mul%E7%9B%AE%E5%BD%95.png" alt="alt"><br><img src="nlp%E7%9B%AE%E5%BD%95.png" alt="alt"></p><p>​代码一般都是半夜写的，只想着能不能跑通没在意结构，现在实验都做完了论文也发了懒得再动代码了（主要怕自己优化结构后出BUG）就大概讲一下代码流程吧。</p><p>​不要问为啥根目录是zywang <span class="github-emoji" style="display:inline;vertical-align:middle"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在人家服务器上跑的。</p><h2 id="代码流程："><a class="header-anchor" href="#代码流程：">¶</a>代码流程：</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>数据集划分：按照 70:15:15 划分数据集包括文本和图片（主要使用xlrd包对数据集annotations中的文件进行处理，也可以使用其他方法对.tsv文件进行处理）</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>使用train_vgg训练VGG16模型，得到xx.pth</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>使用nlp中的main.py训练FastTest模型，生成xx.bin</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>分别调用.pth和.bin文件生成vector</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>将生成的vector放入train_softmax.py进行训练</p>]]></content>
      
      
      <categories>
          
          <category> 小论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastText </tag>
            
            <tag> vgg </tag>
            
            <tag> multimodal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内存共享</title>
      <link href="2021/06/11/Linux%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB/"/>
      <url>2021/06/11/Linux%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1>Linux内存共享</h1><h1>一、共享内存的概念</h1><p>共享内存（Shared Memory）就是允许多个进程访问同一个内存空间，是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读/写加锁，可以使用信号量。</p><h1>二、相关函数</h1><p>Linux中提供了一组函数用于操作共享内存，程序中需要包含以下头文件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="1、shmget函数"><a class="header-anchor" href="#1、shmget函数">¶</a>1、shmget函数</h2><p>shmget函数用来获取或创建共享内存，它的声明为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数key是共享内存的键值，是一个整数，typedef unsigned int key_t，是共享内存在系统中的编号，不同共享内存的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。</p><p>参数size是待创建的共享内存的大小，以字节为单位。</p><p>参数shmflg是共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存。</p><h2 id="2、shmat函数"><a class="header-anchor" href="#2、shmat函数">¶</a>2、shmat函数</h2><p>把共享内存连接到当前进程的地址空间。它的声明如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数shm_id是由shmget函数返回的共享内存标识。</p><p>参数shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p>参数shm_flg是一组标志位，通常为0。</p><p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p><h2 id="3、shmdt函数"><a class="header-anchor" href="#3、shmdt函数">¶</a>3、shmdt函数</h2><p>该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。它的声明如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数shmaddr是shmat函数返回的地址。</p><p>调用成功时返回0，失败时返回-1.</p><h2 id="4、shmctl函数"><a class="header-anchor" href="#4、shmctl函数">¶</a>4、shmctl函数</h2><p>删除共享内存，它的声明如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数shm_id是shmget函数返回的共享内存标识符。</p><p>参数command填IPC_RMID。</p><p>参数buf填0。</p><p>解释一下，shmctl是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用，所以不介绍了。</p><p><strong>注意，用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。</strong></p><h1>三、示例程序</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">int</span> pid;    <span class="comment">// 进程编号。</span></span><br><span class="line"> <span class="keyword">char</span> name[<span class="number">51</span>]; <span class="comment">// 进程名称。</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="comment">// 共享内存的标志。</span></span><br><span class="line"> <span class="keyword">int</span> shmid;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取或者创建共享内存，键值为0x5005。</span></span><br><span class="line"> <span class="keyword">if</span> ( (shmid=shmget(<span class="number">0x5005</span>, <span class="keyword">sizeof</span>(struct st_pid), <span class="number">0640</span>|IPC_CREAT))==<span class="number">-1</span>)</span><br><span class="line"> { <span class="built_in">printf</span>(<span class="string">"shmget(0x5005) failed\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 用于指向共享内存的结构体变量。</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">st_pid</span> *<span class="title">stpid</span>=</span><span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 把共享内存连接到当前进程的地址空间。</span></span><br><span class="line"> <span class="keyword">if</span> ( (stpid=(struct st_pid *)shmat(shmid,<span class="number">0</span>,<span class="number">0</span>))==(<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line"> { <span class="built_in">printf</span>(<span class="string">"shmat failed\n"</span>); <span class="keyword">return</span> <span class="number">-1</span>; }</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pid=%d,name=%s\n"</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line"></span><br><span class="line"> stpid-&gt;pid=getpid();</span><br><span class="line"> <span class="built_in">strcpy</span>(stpid-&gt;name,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pid=%d,name=%s\n"</span>,stpid-&gt;pid,stpid-&gt;name);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把共享内存从当前进程中分离。</span></span><br><span class="line"> shmdt(stpid);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除共享内存。</span></span><br><span class="line"> <span class="comment">// if (shmctl(shmid,IPC_RMID,0)==-1)</span></span><br><span class="line"> <span class="comment">// { printf("shmctl failed\n"); return -1; }</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>四、其它的操作命令</h1><p>用ipcs -m可以查看系统的共享内存，内容有键值（key），共享内存编号（shmid），创建者（owner），权限（perms），大小（bytes）。</p><p>​</p><p>用ipcrm -m 共享内存编号，可以手工删除共享内存，如下：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux信号</title>
      <link href="2021/06/10/Linux%E4%BF%A1%E5%8F%B7/"/>
      <url>2021/06/10/Linux%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1>Linux信号</h1><h2 id="1、信号的基本概念"><a class="header-anchor" href="#1、信号的基本概念">¶</a>1、信号的基本概念</h2><p>信号（signal）是软件中断，是进程之间相互传递消息的一种方法，用于通知进程发生了事件，但是，不能给进程传递任何数据。</p><p>信号产生的原因有很多，在Linux下，可以用kill和killall命令发送信号。</p><h2 id="2、信号的类型"><a class="header-anchor" href="#2、信号的类型">¶</a>2、信号的类型</h2><table><thead><tr><th>信号名</th><th style="text-align:center">信号值</th><th style="text-align:center">默认处理动作</th><th style="text-align:left">发出信号的原因</th></tr></thead><tbody><tr><td>SIGHUP</td><td style="text-align:center">1</td><td style="text-align:center">A</td><td style="text-align:left">终端挂起或者控制进程终止</td></tr><tr><td><strong>SIGINT</strong></td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>键盘中断Ctrl+c</strong></td></tr><tr><td>SIGQUIT</td><td style="text-align:center">3</td><td style="text-align:center">C</td><td style="text-align:left">键盘的退出键被按下</td></tr><tr><td>SIGILL</td><td style="text-align:center">4</td><td style="text-align:center">C</td><td style="text-align:left">非法指令</td></tr><tr><td>SIGABRT</td><td style="text-align:center">6</td><td style="text-align:center">C</td><td style="text-align:left">由abort(3)发出的退出指令</td></tr><tr><td>SIGFPE</td><td style="text-align:center">8</td><td style="text-align:center">C</td><td style="text-align:left">浮点异常</td></tr><tr><td><strong>SIGKILL</strong></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>AEF</strong></td><td style="text-align:left"><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td></tr><tr><td>SIGSEGV</td><td style="text-align:center">11</td><td style="text-align:center">C</td><td style="text-align:left">无效的内存引用</td></tr><tr><td>SIGPIPE</td><td style="text-align:center">13</td><td style="text-align:center">A</td><td style="text-align:left">管道破裂，写一个没有读端口的管道。</td></tr><tr><td><strong>SIGALRM</strong></td><td style="text-align:center"><strong>14</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>由alarm(2)发出的信号</strong></td></tr><tr><td><strong>SIGTERM</strong></td><td style="text-align:center"><strong>15</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td></tr><tr><td><strong>SIGUSR1</strong></td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>用户自定义信号1</strong></td></tr><tr><td><strong>SIGUSR2</strong></td><td style="text-align:center"><strong>12</strong></td><td style="text-align:center"><strong>A</strong></td><td style="text-align:left"><strong>用户自定义信号2</strong></td></tr><tr><td><strong>SIGCHLD</strong></td><td style="text-align:center"><strong>17</strong></td><td style="text-align:center"><strong>B</strong></td><td style="text-align:left"><strong>子进程结束信号</strong></td></tr><tr><td>SIGCONT</td><td style="text-align:center">18</td><td style="text-align:center"></td><td style="text-align:left">进程继续（曾被停止的进程）</td></tr><tr><td>SIGSTOP</td><td style="text-align:center">19</td><td style="text-align:center">DEF</td><td style="text-align:left">终止进程</td></tr><tr><td>SIGTSTP</td><td style="text-align:center">20</td><td style="text-align:center">D</td><td style="text-align:left">控制终端（tty）上按下停止键</td></tr><tr><td>SIGTTIN</td><td style="text-align:center">21</td><td style="text-align:center">D</td><td style="text-align:left">后台进程企图从控制终端读</td></tr><tr><td>SIGTTOU</td><td style="text-align:center">22</td><td style="text-align:center">D</td><td style="text-align:left">后台进程企图从控制终端写</td></tr></tbody></table><p>处理动作一项中的字母含义如下</p><p>A 缺省的动作是终止进程。</p><p>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。</p><p>C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</p><p>D 缺省的动作是停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。</p><p>E 信号不能被捕获。</p><p>F 信号不能被忽略。</p><h2 id="3、信号的处理"><a class="header-anchor" href="#3、信号的处理">¶</a>3、信号的处理</h2><p>进程对信号的处理方法有三种：</p><p>1）对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。</p><p>2）设置中断的处理函数，收到信号后，由该函数来处理。</p><p>3）忽略某个信号，对该信号不做任何处理，就像未发生过一样。</p><p>signal函数可以设置程序对信号的处理方式。</p><p>函数声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数signum表示信号的编号。</p><p>参数handler表示信号的处理方式，有三种情况：</p><p>1）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。</p><p>2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。</p><p>3）SIG_IGN：忽略参数signum所指的信号。</p><h2 id="4、信号有什么用"><a class="header-anchor" href="#4、信号有什么用">¶</a>4、信号有什么用</h2><p>服务程序运行在后台，如果想让中止它，杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有安排善后工作。</p><p>如果向服务程序发送一个信号，服务程序收到这个信号后，调用一个函数，在函数中编写善后的代码，程序就可以有计划的退出。</p><p>向服务程序发送0的信号，可以检测程序是否存活。</p><h2 id="5、信号应用示例"><a class="header-anchor" href="#5、信号应用示例">¶</a>5、信号应用示例</h2><p>在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">64</span>;ii++) signal(ii,SIG_IGN);</span><br></pre></td></tr></tbody></table></figure><p>这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。</p><p>程序在运行的进程中，如果按Ctrl+c，将向程序发出SIGINT信号，编号是2。</p><p>采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。</p><p>采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p><p>设置SIGINT和SIGTERM两个信号的处理函数，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* 本程序演示信号的用法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXIT</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"收到了信号%d，程序退出。\n"</span>,sig);</span><br><span class="line"> <span class="comment">// 在这里添加释放资源的代码</span></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 程序退出。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">64</span>;ii++) signal(ii,SIG_IGN); <span class="comment">// 屏蔽全部的信号</span></span><br><span class="line"> signal(SIGINT,EXIT); signal(SIGTERM,EXIT); <span class="comment">// 设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// 每隔一秒执行一次任务。</span></span><br><span class="line"> {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"执行了一次任务。\n"</span>);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不管是用Ctrl+c还是kill，程序都能体面的退出。</p><h2 id="6、发送信号"><a class="header-anchor" href="#6、发送信号">¶</a>6、发送信号</h2><p>Linux操作系统提供了kill和killall命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。</p><p>函数声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>kill函数将参数sig指定的信号给参数pid 指定的进程。</p><p>参数pid 有几种情况：</p><p>1）pid&gt;0 将信号传给进程号为pid 的进程。</p><p>2）pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。</p><p>3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。</p><p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。</p><p>返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。</p><p>EINVAL：指定的信号码无效（参数 sig 不合法）。</p><p>EPERM：权限不够无法传送信号给指定进程。</p><p>ESRCH：参数 pid 所指定的进程或进程组不存在。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个博客</title>
      <link href="2021/06/07/hello-world/"/>
      <url>2021/06/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>本博客主要记录 <a href="https://github.com/GanHY97">XGG</a> 的一些学习日常以及生活点滴。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
